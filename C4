#MY REORDER AND IMPLEMENTATION OF THE FULL CODE OF C4: 

import numpy as np
import math
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy import stats

#this defintion is the same as the one in Kasturi's C1, C2, C3 and C5 code
def euler_circular_error(G=4*math.pi**2, dt=1e-4, fraction=0.1):
    """
    Simulate circular orbit (a=1, e=0 -> T=1 yr) for a fraction of orbit.
    Exact solution: x(t) = cos(2π * t / T), y(t) = sin(2π * t / T)
    """
    a = 1.0
    # Initial conditions for circular orbit: r = a, v = sqrt(GM/a)
    x, y = a, 0.0
    vx, vy = 0.0, math.sqrt(G / a)  # since M=1

    T = a**1.5
    total_time = fraction * T
    nsteps = int(total_time / dt)

    # Integrate (Euler–Cromer)
    for _ in range(nsteps):
        r = math.hypot(x, y)
        ax = -G * x / r**3
        ay = -G * y / r**3
        vx += ax * dt
        vy += ay * dt
        x += vx * dt
        y += vy * dt

    # Exact x at time = fraction * T
    theta_exact = 2 * math.pi * fraction
    x_exact = a * math.cos(theta_exact)
    error = abs(x - x_exact)
    return error


#implementing leapfrog algorithm
def leapfrog_circular_error(dt=1e-4, fraction=0.1):
    a = 1.0
    G = 4*math.pi**2
    # Initial conditions for circular orbit
    x, y = a, 0.0
    vx, vy = 0.0, math.sqrt(G / a) #M=1 

    T = a**1.5
    total_time = fraction * T
    nsteps = int(total_time / dt)

    def acceleration(x, y): #differention of x twice
        r = math.hypot(x, y)
        ax = -G * x / r**3
        ay = -G * y / r**3
        return ax, ay

    for _ in range(nsteps):
        ax, ay = acc(x, y)

        # half-step velocity
        vx_half = vx + 0.5 * ax * dt
        vy_half = vy + 0.5 * ay * dt

        # full-step position
        x_new = x + vx_half * dt
        y_new = y + vy_half * dt

        ax2, ay2 = acc(x_new, y_new)

        # full-step velocity
        vx = vx_half + 0.5 * ax2 * dt
        vy = vy_half + 0.5 * ay2 * dt

        x, y = x_new, y_new

    theta_exact = 2 * math.pi * fraction
    return abs(x - math.cos(theta_exact))

#implementing RK2 method
def rk2_circular_error(dt=1e-4, fraction=0.1):
    """
    Midpoint RK2 — 2nd order.
    """
    a = 1.0
    x, y = a, 0.0
    vx, vy = 0.0, math.sqrt(G / a)

    T = a**1.5
    total = fraction * T
    nsteps = int(total / dt)

    for _ in range(nsteps):

        ax1, ay1 = acc(x, y)
        k1x, k1y = vx, vy
        k1vx, k1vy = ax1, ay1

        xm = x + 0.5 * dt * k1x
        ym = y + 0.5 * dt * k1y
        vmx = vx + 0.5 * dt * k1vx
        vmy = vy + 0.5 * dt * k1vy

        ax2, ay2 = acc(xm, ym)

        x += dt * vmx
        y += dt * vmy
        vx += dt * ax2
        vy += dt * ay2

    theta_exact = 2 * math.pi * fraction
    return abs(x - math.cos(theta_exact))

#RK4 method copied from Amy
def rk4_circular_error(dt=1e-4, fraction=0.1):
    """
    Simulating the RK4 (Runge Kutta 4) Method 
    """
    a = 1.0
    G = 4*math.pi**2
    # Initial conditions for circular orbit
    x, y = a, 0.0
    vx, vy = 0.0, math.sqrt(G / a) #M=1 

    T = a**1.5
    total_time = fraction * T
    nsteps = int(total_time / dt)

    def acceleration(x, y): #differention of x twice
        r = math.hypot(x, y)
        ax = -G * x / r**3
        ay = -G * y / r**3
        return ax, ay

    for _ in range(nsteps): #RK4 method
        ax1, ay1 = acceleration(x, y) #k1 (like 1st time step)
        k1x, k1y = vx, vy #differential of x once
        k1vx, k1vy = ax1, ay1 #differential of x twice or vx/vy once

        ax2, ay2 = acceleration(x + k1x/2*dt, y + k1y/2*dt) #k2 (second step)
        k2x, k2y = vx + k1vx/2*dt, vy + k1vy/2*dt
        k2vx, k2vy = ax2, ay2

        ax3, ay3 = acceleration(x + k2x/2*dt, y +  k2y/2*dt) #k3 (third step)
        k3x, k3y = vx + k2vx/2*dt, vy + k2vy/2*dt
        k3vx, k3vy = ax3, ay3

        ax4, ay4 = acceleration(x + k3x*dt, y + k3y*dt) #k4 (4th step)
        k4x, k4y = vx + k3vx*dt, vy + k3vy*dt
        k4vx, k4vy = ax4, ay4

        x = x + (dt/6.0) * (k1x + 2*k2x + 2*k3x + k4x) 
        y = y+ (dt/6.0) * (k1y + 2*k2y + 2*k3y + k4y)
        vx = vx+ (dt/6.0) * (k1vx + 2*k2vx + 2*k3vx + k4vx)
        vy = vy + (dt/6.0) * (k1vy + 2*k2vy + 2*k3vy + k4vy)

    # Exact x at time = fraction * T
    theta_exact = 2 * math.pi * fraction
    x_exact = a * math.cos(theta_exact)
    error = abs(x - x_exact)
    return error

dts = np.array([1e-2, 5e-3, 1e-3, 5e-4, 1e-4, 5e-5, 1e-5])
errors_eu = np.array([euler_circular_error(dt) for dt in dts])
errors_lf = np.array([leapfrog_circular_error(dt) for dt in dts])
errors_rk2 = np.array([rk2_circular_error(dt) for dt in dts])
errors_rk4 = np.array([rk4_circular_error(dt) for dt in dts])

#editing code supplied by Amy
def fitconvergence(dts, errors): #made fit for covergence to use on both RK4 and Euler-Cromer
    log_dt = np.log10(dts)
    log_err = np.log10(errors)
    slope, intercept, r_value, _, std_err = stats.linregress(log_dt, log_err) 
    C_fit = 10**intercept
    return slope, C_fit, r_value, std_err

nfit_eu, cintercept_eu, corr_eu, std_eu = fitconvergence(dts, errors)
nfit_lf, cintercept_lf, corr_lf, std_lf = fitconvergence(dts, errors_lf)
nfit_rk2, cintercept_rk2, corr_rk2, std_rk2 = fitconvergence(dts, errors_rk2)
nfit_rk4, cintercept_rk4, corr_rk4, std_rk4 = fitconvergence(dts, errors_rk4)

print(f"Euler–Cromer order n = {nfit_eu:.4g} ± {std_eu:.4g}, (R² = {corr_eu**2:.4f})")
print(f"Leapfrog order n = {nfit_lf:.4g} ± {std_lf:.4g}, (R² = {corr_lf**2:.4f})")
print(f"RK2 order n = {nfit_rk2:.4g} ± {std_rk2:.4g}, (R² = {corr_rk2**2:.4f})")
print(f"RK4 order n = {nfit_rk4:.4g} ± {std_rk4:.4g}, (R² = {corr_rk4**2:.4f})")

print(f"Euler–Cromer order       = {n_eu:.3f} ± {s_eu:.3f}  (expected 1)")
print(f"Leapfrog order           = {n_lf:.3f} ± {s_lf:.3f}  (expected 2)")
print(f"RK2 (Midpoint) order     = {n_rk2:.3f} ± {s_rk2:.3f} (expected 2)")
print(f"RK4 order                = {n_rk4:.3f} ± {s_rk4:.3f} (expected 4)")

#Plotting all results
# Plot(basically the same as the C3)
plt.figure(figsize=(6,4))
plt.loglog(dts, errors, "o-", label="Euler–Cromer")
plt.loglog(dts, errors_lf, "s-", label="Leapfrog")
plt.loglog(dts, errors_rk2, "d-", label="RK2")
plt.loglog(dts, errors_rk4, "^-", label="RK4")
plt.xlabel("Δt (yr)")
plt.ylabel("Global error in x")
plt.title("Convergence Comparison of All Integrators (Circular Orbit)")
plt.legend(); plt.grid(True, which="both", ls="--", alpha=0.5)
plt.show()
